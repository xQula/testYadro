## Yadro TATLIN Data Services
### Задание
Устройство хранения данных типа лента (Tape) предназначено для последовательной записи и чтения
данных. 

Считывающая/записывающая магнитная головка неподвижна во время чтения и записи, а
лента имеет возможность двигаться в обоих направлениях. Запись и чтение информации возможны в
ячейку ленты, на которой в данный момент находится магнитная головка. 

Перемещения ленты –
затратная по времени операция – лента не предназначена для произвольного доступа.
Имеется входная лента длины `N` (где `N` – велико), содержащая элементы типа `integer (2^32)`. Имеется
выходная лента такой же длины. Необходимо записать в выходную ленту отсортированные по
возрастанию элементы с входной ленты. Есть ограничение по использованию оперативной памяти – не
более `M` байт (`M` может быть < `N`, т.е. загрузить все данные с ленты в оперативную память не
получится). Для реализации алгоритма можно использовать разумное количество временных лент, т.е.
лент, на которых можно хранить какую-то временную информацию, необходимую в процессе работы
алгоритма.

Необходимо создать проект С++, компилируемый в консольное приложение, которое реализует
алгоритм сортировки данных с входной ленты на выходную. Необходимо сделать следующее:
- Определить интерфейс для работы с устройством типа лента.
- Написать класс, реализующий этот интерфейс и эмулирующий работу с лентой посредством
обычного файла. Должно быть возможно сконфигурировать (без перекомпиляции – например,
через внешний конфигурационный файл, который будет прочитан на старте приложения)
задержки по записи/чтению элемента с ленты, перемотки ленты, и сдвига ленты на одну
позицию.
- Файлы временных лент можно сохранять в директорию `/tmp/`.
- Написать класс, реализующий алгоритм сортировки данных с входной ленты на выходную.
- Консольное приложение должно принимать на вход имя входного и выходного файлов и
производить сортировку.
- Желательно написать юнит-тесты.

### Решение

#### Алгоритм сортировки данных с входной ленты на выходную.

- Читаем входную ленту в `vector` из `std::istream` на константу `N`, котороя указанна в файлу `config.ini`.
- Сортируем входную ленту с помощью функции `std::sort`.
- Записываем отсортированную ленту во временый файл.
- И так повторяем пока не закончится входная лента и не получится `К` файлов.
- Временные ленты хранятся по пути `std::filesystem::temp_directory_path` на windows `%appdata%/local/temp` на линукс `~/tmp/`
- Теперь читаем временные ленты по одному элементу в `std::priority_queue`, в начале будет хранится самый маленький элемент, поэтому в начале ленты будут храниться наименьший элемент.
- Наименьший элемент записываем в выходную ленту.
- И так продолжаем пока временные ленты не закончатся.

#### Реализация основных структур

- Интерфейс  ленты определен в классе `ITape`.
- Реализация ленты определена в `Tape`.
- Алгоритм реализован в функции `sort_into`.
- Вспомогательные функции определены в `namespace yuliy_test_task::common`.
- Структуры временных лент определены в струтуре `TempFile`.   
- Интерфейс для идиомы impl определена в `IO`.
- Реалиазация бинарной ленты определена в `BinaryTape`.

#### Логика архитектуры

Имея интерфейс ленты `ITape`, мы наследуемся от нее и производим класс-наследник `Tape`. 
Чтобы быть более гибким в выборе реализации `Tape`, убираем реализацию в отдельную сущность `IO`,
с помощью идиомы impl. Реализация бинарной ленты определяется в отдельной сущности `BinaryTape`.
С помощью concept `TapeIO`, мы четко задаем какими методома должна обладать сущность impl, тем самым,
теперь есть возможность  подменять бинарную ленту, на любую другую, лишь бы она была унаследованной 
от `IO` и соблюдала concept `TapeIO`.

### Сборка

Система сборка `CMake`. Конфиг файл `config.ini`, должен лежать рядом с исполняемым файлом.

- запуск сборки в консоли из корневой папки
```shell
mkdir build && cp ./config.ini ./build && cmake -B build -GNinja && cmake --build build --paralell
```

- генерация входной ленты используя питоновский скрипт, значeния хранятся в бинарном виде.

```shell
python3 generate.py -c ${N} -m ${name.tape}
```

`${N}` - количество элементов в ленте.  
`${name.tape}` - имя ленты, например tape_input.tape   
**пример**

```shell
python3 generate.py -c 1000 -m tape_input.tape
```

- просмотр сгенерированной ленты с помощью  питоновского скрипта

```shell
python3 view.py ${name.tape}
```

`${name.tape}` - имя ленты, например tape_input.tape  

- запуск самого приложения

```shell
./yuliy ${name_input.tape} ${name_output.tape}
```
`${name_input.tape}` - путь и имя входной ленты  
`${name_output.tape}`- путь и имя выходной ленты  
Запуск должен быть из папки где находится сам файл.

- запуск unit-тестов

```shell
./yuliy-test
```
По умолчанию опция cmake `INTEGRATION_TESTS` включена.  
Запуск должен быть из папки где находится сам файл.